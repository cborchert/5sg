# Stupid Simple Svelte Static Site Generator (5SG)

## Introduction

5sg stands for **s**tupid **s**imple **s**velte **s**tatic **s**ite generator. It's a static site generator (SSG) in the making which focuses on ease of development, simplicity of structure, and speed of delivery. It takes in markdown and svelte, and outputs html. I had planned on changing the name, mostly because French google mostly turns up 5th week pregnancy results (5√®me semaine de grossesse), but ü§∑‚Äç‚ôÄÔ∏è.

## Big ideas

### Simple build process

1. Install 5sg using `npm install -S 5sg` or `yarn add 5sg`
2. Put your content files (`*.md` and `.svelte`) in `<PROJECT_ROOT>/src/content/`.
3. Pick your adventure
   - Static build: run `5sg` to build to the `<PROJECT_ROOT>/public` directory
   - Development: run `5sg --serve` to build to the `<PROJECT_ROOT>/public` directory and serve on http://localhost:3221

### Installation using a template

You can install a 5sg template using [degit](https://www.npmjs.com/package/degit)

For a basic starter site use the template at https://github.com/cborchert/5sg-basic-template

```
npm install -g degit
degit cborchert/5sg-basic-template my-5sg-site
cd my-5sg-site
npm install
npm run dev
```

For more complicated a blog site use the blog template at https://github.com/cborchert/5sg-blog-template

```
npm install -g degit
degit cborchert/5sg-blog-template my-5sg-blog
cd my-5sg-blog
npm install
npm run dev
```

### Intuitive, file-based routing

`src/content/foo/bar.(md|svelte)` generates `public/foo/bar.html`

### Small files and partial hydration

All generated html is feather-weight and the client loads no javascript unless needed.

All images are processed to use modern formats where possible.

### Customization and automation

Customize everything from config.js

- Your sitemap and webmanifest are taken care of for you
- You can easily add dynamically rendered pages such as a blog feed and category pages
- You can apply custom layouts to your pages, either defined by the content path or the `layout` entry in the content's frontmatter

### Dynamic pages

If you're building a blog, you'll probably want a blogfeed. 5sg provides a way to build dynamic pages using your content.

### Access your content data at every inpoint

Using the special `deriveProps` export, every layout and top level `.svelte` file has access to the meta data of every other file.This means that you can easily create navigation between sibling blog posts, for example.

## More nitty-gritty

### Project structure

```
<PROJECT_ROOT>/
‚îú‚îÄ .5sg/ # generated by .5sg you can ignore
‚îú‚îÄ public/ # the output of the 5sg build process
‚îú‚îÄ src/
‚îÇ  ‚îú‚îÄ content/ # This is where your content lives! src/content/foo/bar.(md|svelte) generates public/foo/bar.html
‚îÇ  ‚îú‚îÄ static/ # Unprocessed content. All files are copied to public/static/
‚îÇ  ‚îú‚îÄ <YOUR CUSTOM FILES AND FOLDER>
‚îú‚îÄ .gitignore
‚îú‚îÄ config.js # Optional config file
‚îú‚îÄ package.json
```

I recommend structuring your `<PROJECT_ROOT>/src` directory like this, but you do what you want.

```
<PROJECT_ROOT>/src/
‚îú‚îÄ content/ # This is where your content lives! src/content/foo/bar.(md|svelte) generates public/foo/bar.html
‚îú‚îÄ static/ # Unprocessed content. All files are copied to public/static/
‚îú‚îÄ components / # your svelte components
‚îú‚îÄ layouts/ # your page-level layout components
‚îú‚îÄ dynamicPages/ # your components for dynamically rendered pages
```

### Recommended `.gitignore`

```
node_modules/
public/
.5sg/
```

### Recommended `package.json` scripts

```
{
   // ... the rest of your package.json
   "scripts": {
    "build": "5sg",
    "dev": "5sg --serve",
    // ...your test scripts etc. here
  },
}
```

### Partial Hydration

All svelte components are rendered to static html, and, by default, that's where the story ends.

However if you need the component to be hydrated (i.e. interactive), you can use the custom `<Hydrate />` component from `5sg`.
Hydrate accepts two props:

- `component`: the component to hydrate
- and `props`: the component's props

Example:

```svelte
<script>
  import Hydrate from "5sg/Hydrate";
  import Count from "../components/Count.svelte";
</script>

<h1>Hello, World!</h1>
<Count name="non-hydrated, non-interactive counter üò¢" />
<Hydrate component={Count} props={{ name: "hydrated counter ü§Ø" }} />
```

Note that the rendered component will be placed in a `<div>` which may have layout implications.

### Custom markdown preprocessors

By default, markdown files are processed using [remark](https://github.com/remarkjs/remark/tree/main/packages/remark) and the following plugins:

[remark-highlight.js](https://github.com/remarkjs/remark-highlight.js#readme): to process code fences (you need to add the appropriate global for highlighting to work),
[remark-gfm](https://github.com/remarkjs/remark-gfm#readme): to add github style markdown transformations
and [remark-gemoji](https://github.com/remarkjs/remark-gemoji#readme): to transform emojis

If you want to change this, simply define the `remarkPlugins` property as an array of plugins in `config.js`

```js
// config.js
import gemoji from 'remark-gemoji';
import footnotes from 'remark-footnotes';
import highlight from 'remark-highlight.js';
import gfm from 'remark-gfm';

export default {
  // ...other config
  remarkPlugins: [highlight, gfm, gemoji, footnotes],
};
```

if you need to pass options to the plugin you can do so by passing an tuple: `[plugin, options]`:

```js
import gemoji from 'remark-gemoji';
import highlight from 'remark-highlight.js';
import gfm from 'remark-gfm';
import customPluginWithOptions from './plugin.js';

export default {
  remarkPlugins: [highlight, gfm, gemoji, [customPluginWithOptions, { foo: 'bar' }]],
};
```

### Syntax highlighting

Although we're using `remark-highlight.js` by default to enable syntax highlighting in code fences, you need to include one of their themes. There's an explorer [here](https://highlightjs.org/static/demo/), and you can use a cdn to include the styles (see [the highlight.js usage page](https://highlightjs.org/usage/)), or download one of the styles from [their repo](https://github.com/highlightjs/highlight.js/tree/main/src/styles) and include it yourself.

### Custom Layouts

By default, content is thrown into a plain old html wrapper. In order to give it some style, you'll need to be able to assign it a layout. A layout is simply a svelte file which contains a `<slot />` that the transformed content is injected into.

For example, the markdown content

```md
# Hello [world](http://www.example.com) !
```

plus the layout

```svelte

<div>
  <nav><a href="/">Home</a></nav>
  <main>
    <slot />
  </main>
</div>

<svelte:head>
  <!-- import global css -->
  <link rel="stylesheet" href="/static/styles/global.css" />
  <!-- highlight.js theme for highlighting code blocks (for blogs and documentation sites, etc.) -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/default.min.css">
</svelte:head>

<style>
  main {
    width: 1024px;
    margin: 20px auto;
  }
</style>

```

would result in an html file kindof like this

```html
<html>
  <head>
    <link rel="stylesheet" href="/static/styles/global.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/default.min.css" />
    <style>
      main {
        width: 1024px;
        margin: 20px auto;
      }
    </style>
  </head>
  <body>
    <div>
      <nav><a href="/">Home</a></nav>
      <main>
        <h1>Hello <a href="http://www.example.com">world</a></h1>
      </main>
    </div>
  </body>
</html>
```

You can define the layouts in the `config.js` file

```js
// config.js
export default {
  // ...other config
  layouts: { blog: `src/layouts/Blog.svelte`, _: `src/layouts/Page.svelte` },
};
```

a markdown file will use the `_` layout by default, and it will use any other layout based on one of two things:

1. If its directory relative to `src/content` matches the layout name. For example, by default all files in `src/content/blog` will use the `blog` layout.
2. If the frontmatter property `layout` matches the layout name.

Of note:

- If the frontmatter property is defined, it supercedes the directory-based layout
- If the frontmatter property `layout` === false, no layout will be used.
- The layout name is case insensitive
- Layouts are not applied to svelte components by default. You can just import the component and use it in your svelte component.

### Markdown Frontmatter in Layouts

Layouts receive all properties declared in a markdown file's frontmatter as an object prop called `metadata`.

Example:

```md
---
title: qui eius qui quisquam!
date: 2021-01-01T20:52:15.045Z
tags:
  - perferendis
  - foo
  - bar
layout: false
---

# Hello world
```

```svelte
<script>
  export let metadata = {};
  const { title, date, tags, layout } = metadata;
  // title: string === "qui eius qui quisquam!"
  // date: string === "2021-01-01T20:52:15.045Z"
  // tags: string[] === ["perferendis", "foo", "bar"]
  // layout: boolean === false
  // note, if we had had `layout: blog`, then layout would be a string "blog"
</script>

<slot />

```

### Layout and svelte file deriveProps

Top-level svelte files (i.e. .svelte files in the content folder, layout files, and dynamic page files) have access to the meta data of all content nodes in the project. For the moment the way to access this data is a bit convoluted, and it was done this way as a way to get around atrociously large files in the build process. There may be a better way, and this is one of those things that, we might expect to change in a v1 release.

Here's how it works:

You can export a function called `deriveProps` from the `context="module"` script of your page/layout file which takes in all the content node data, and transforms it into props to be injected into the component.

Here's a basic reference of `deriveProps`:

```js
/**
 * @typedef {Object} NodeMetaEntry
 * @property {Object} metadata the exported frontmatter
 * @property {string} publicPath the publish path with extension
 */

/**
 * @typedef {Object} ContentNode a single block of content in the nodeMap
 * @property {string} facadeModuleId the path of the input file
 * @property {string} fileName the path relative to .5sg/build/bundled for the component
 * @property {string} name the publish path / slug
 * @property {string} publicPath the publish path with extension
 * @property {boolean} isDynamic if true, the ContentNode was created dynamically rather than from a file
 */

/**
 *
 * @param {Object} context the context of the current content node
 * @param {Object<string, NodeMetaEntry>} context.nodeMeta all the content node information, where the key is the path of the content node and the value is the content node meta information
 * @param {ContentNode} context.nodeData the content node information of the current node
 * @returns {Object} the props to be injected into the component
 */
function deriveProps(context) {
  const { nodeMeta = {}, nodeData = {} } = context;

  return {
    //... the injected derived props
  };
}
```

#### A basic example

```svelte
<script context="module">
  export const deriveProps = ({ nodeMeta = {} }) => {
    const numberOfContentNodes = Object.keys(nodeMeta).length;
    return {
      numberOfContentNodes,
    }
  }
</script>

<script>
  // injected from deriveProps
  export let numberOfContentNodes;
</script>

<h1>There are {numberOfContentNodes} in this project</h1>
```

#### A more complicated example

```svelte
<script context="module">
  // layouts/Blog.svelte

  export const deriveProps = ({ nodeMeta = {}, nodeData = { name: "" } }) => {
    // create sibling pages

    // get an array containing only blog nodes, sorted by date
    const blogPages = Object.values(nodeMeta)
      // get all the content nodes in the src/content/blog/ directory
      .filter((node) => node.publicPath.startsWith("blog/"))
      // sort by date
      .sort((a, b) => {
        const dateA = (a.metadata && a.metadata.date) || "";
        const dateB = (b.metadata && b.metadata.date) || "";
        // newest first
        return dateA > dateB ? -1 : 1;
      });

    // get the current node's position in the array
    const currentPath = `${nodeData.publicPath}`;
    const currentIndex = blogPages.findIndex(
      (node) => node.publicPath === currentPath;
    );

    // get the siblings

    // the previous or false
    const prevPost = currentIndex > 0 && blogPages[currentIndex - 1];

    // the next or false
    const nextPost =
      currentIndex < blogPages.length - 1 && blogPages[currentIndex + 1];

    // these will be injected into the component
    return {
      nextPost,
      prevPost,
    };
  };
</script>

<script>
  // these props are injected thanks to deriveProps above
  export let nextPost;
  export let prevPost;
</script>

<article>
  <slot />
  <footer>
    <nav>
      <ul class="sibling-navigation">
        <li>
          {#if prevPost}
            <a href="/{prevPost.publicPath}">‚Üê {prevPost.metadata.title}</a>
          {/if}
        </li>
        <li>
          {#if nextPost}
            <a href="/{nextPost.publicPath}">{nextPost.metadata.title} ‚Üí</a>
          {/if}
        </li>
      </ul>
    </nav>
  </footer>
</article>
```

### Site Meta and SEO

The site meta data from config.js is injected into each top-level svelte component (layout, content page, and dynamically rendered page) as the prop `siteMeta`.

For example, if in `config.js` you have

```
export default {
  siteMeta: {
    name: "My 5sg site!",
  }
}
```

then in the template `Page.svelte` or in the content file `src/content/index.svelte` you could have

```svelte
<script>
  export let siteMeta = {};
  const { name } = siteMeta;
</script>

<h1>Welcome to {name}</h1>
```

Additionally, the following siteMeta values are used to create a `site.webmanifest` file:

```
name,
short_name,
description,
icons,
theme_color,
background_color,
display,
```

see the [web.dev guide on manifests](https://web.dev/add-manifest/) for more information.

### Dynamically built pages

** TODO **

### Image processing

** TODO: Better docs **

Basic idea: all .jpg image files which are not in the static folder will be transformed into images which are at most 800w by 400h. We add .avif and .webp file versions, and then we transform all image tags into picture tags with sources.

This will likely be refined before v1, and it will be customizable.

### More config.js

** TODO **

### The static folder

The `src/static` folder is copied directly to `public/static` without any transformations.

## Questions and answers

### What's the deal with the tsconfig file ?

This project doesn't use Typescript, yet, mostly because I wanted to avoid a build step. But I nonetheless wanted to make sure that I had a way to implement type-safety. I'm using a weird mash up of js-doc style type declarations along with a ts-config file so that my text editor and linter can catch type errors. It's hacky, but what about this project ISN'T ?

## Inspirations

5sg was inspired by Gatsby, ElderJS, 11ty, Grav, and MDSvex. I did extensive research on partial hydration after the version 0 was finished, and would like to thank the developers of ElderJS and 7ty for their implementations which made the most sense to me.

## Future plans

Check the project [v1 release candidate](https://github.com/cborchert/5sg/projects/2). Once I have a v1, I truly doubt that I'll do much more work on this other than bugfixes. Hopefully sveltekit gets to a point (and it seems to be rapidly becoming the case), where this project will become obsolete.

Also, the documentation needs A LOT of work. Sorry for anyone who got this far and has no idea what's going on.
