# Stupid Simple Svelte Static Site Generator (5SG)

## Introduction

5sg stands for **s**tupid **s**imple **s**velte **s**tatic **s**ite generator. It's a static site generator (SSG) in the making which focuses on ease of development, simplicity of structure, and speed of delivery. It takes in markdown and svelte, and outputs html. I had planned on changing the name, mostly because French google mostly turns up 5th week pregnancy results (5√®me semaine de grossesse), but ü§∑‚Äç‚ôÄÔ∏è.

## Big ideas

### Simple build process

1. Install 5sg using `npm install -S 5sg` or `yarn add 5sg`
2. Put your content files (`*.md` and `.svelte`) in `<PROJECT_ROOT>/src/content/`.
3. Pick your adventure
   - Static build: run `5sg` to build to the `<PROJECT_ROOT>/public` directory
   - Development: run `5sg --serve` to build to the `<PROJECT_ROOT>/public` directory and serve on http://localhost:3221

### Installation using a template

_Templates Coming Soon_

### Intuitive paths

`src/content/foo/bar.(md|svelte)` generates `public/foo/bar.html`

### Small files and partial hydration

All generated html is feather-weight with no javascript unless needed.

All images are processed to use modern formats where possible.

### Customization and automation

Customize everything from config.js

- Your sitemap and webmanifest are taken care for you
- You can easily add dynamically rendered pages such as a blog feed and category pages
- You can apply custom layouts to your pages, either defined by the content path or the `layout` entry in the content's frontmatter
-

## More nitty-gritty

### Project structure

```
<PROJECT_ROOT>/
‚îú‚îÄ .5sg/ # generated by .5sg you can ignore
‚îú‚îÄ public/ # the output of the 5sg build process
‚îú‚îÄ src/
‚îÇ  ‚îú‚îÄ content/ # This is where your content lives! src/content/foo/bar.(md|svelte) generates public/foo/bar.html
‚îÇ  ‚îú‚îÄ static/ # Unprocessed content. All files are copied to public/static/
‚îÇ  ‚îú‚îÄ <YOUR CUSTOM FILES AND FOLDER>
‚îú‚îÄ .gitignore
‚îú‚îÄ config.js # Optional config file
‚îú‚îÄ package.json
```

I recommend structuring your `<PROJECT_ROOT>/src` directory like this, but you do what you want.

```
<PROJECT_ROOT>/src/
‚îú‚îÄ content/ # This is where your content lives! src/content/foo/bar.(md|svelte) generates public/foo/bar.html
‚îú‚îÄ static/ # Unprocessed content. All files are copied to public/static/
‚îú‚îÄ components / # your svelte components
‚îú‚îÄ layouts/ # your page-level layout components
‚îú‚îÄ dynamicPages/ # your components for dynamically rendered pages
```

### Recommended `.gitignore`

```
node_modules/
public/
.5sg/
```

### Recommended `package.json` scripts

```
{
   // ... the rest of your package.json
   "scripts": {
    "build": "5sg",
    "dev": "5sg --serve",
    // ...your test scripts etc. here
  },
}
```

### Partial Hydration

All svelte components are rendered to static html, and, by default, that's where the story ends.

However if you need the component to be hydrated (i.e. interactive), you can use the custom `<Hydrate />` component from `5sg`.
Hydrate accepts two props:
`component`: the component to hydrate
and `props`: the component's props

Example:

```svelte
<script>
   import Hydrate from "5sg/Hydrate";
  import Count from "../components/Count.svelte";
</script>

<h1>Hello, World!</h1>
<Count name="non-hydrated, non-interactive counter üò¢" />
<Hydrate component={Count} props={{ name: "hydrated counter ü§Ø" }} />
```

Note that the rendered component will be placed in a `<div>` which may have layout implications.

### Custom markdown preprocessors

By default, markdown files are processed using remark and the following plugins:

highlight: to process code fences (you need to add the appropriate global for highlighting to work),
gfm: to add github style markdown transformations
and gemoji: to transform emojis

If you want to change this, simply define the `remarkPlugins` property as an array of plugins in `config.js`

```js
import gemoji from 'remark-gemoji';
import footnotes from 'remark-footnotes';
import highlight from 'remark-highlight.js';
import gfm from 'remark-gfm';

export default {
  remarkPlugins: [highlight, gfm, gemoji, footnotes],
};
```

if you need to pass options to the plugin you can do so by passing an array

```js
import gemoji from 'remark-gemoji';
import highlight from 'remark-highlight.js';
import gfm from 'remark-gfm';
import customPluginWithOptions from './plugin.js';

export default {
  remarkPlugins: [highlight, gfm, gemoji, [customPluginWithOptions, { foo: 'bar' }]],
};
```

### Custom Layouts

### Markdown Frontmatter

### Dynamically built pages

### Site Meta and SEO

### Image processing

### More config.js

## Questions and answers

### What's the deal with the tsconfig file ?

This project doesn't use Typescript, yet, mostly because I wanted to avoid a build step. But I nonetheless wanted to make sure that I had a way to implement type-safety. I'm using a weird mash up of js-doc style type declarations along with a ts-config file so that my text editor and linter can catch type errors. It's hacky, but what about this project ISN'T ?
